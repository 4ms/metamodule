#pragma once
#include "conf/panel_conf.hh"
#include "conf/stream_conf.hh"
#include "util/debouncer.hh"
#include "util/filter.hh"
#include "util/rotary_motion.hh"
#include "util/zip.hh"
#include <array>
#include <cmath>
#include <cstdint>

namespace MetaModule
{

// A catch-all of data shared between cores
// TODO: separate out into data that follows the same paths
// Idea:
// Controls <-> Audio is in MetaParams
// Controls -> GUI is in a new thing, like SyncParams (hsem to block write/read)
// Audio -> GUI should be in ParamsState
// GUI <-> GUI is in PageManager::GuiState
struct MetaParams {

	// Populated by controls, (passes to audio, which does not use it), used by GUI via SyncParams
	// TODO: could controls pass directly to GUI via SPSC queue?
	Toggler rotary_button;
	RotaryMotion rotary{};
	RotaryMotion rotary_pushed{};
	std::array<Toggler, PanelDef::NumMetaRgbButton> meta_buttons{};

	// Populated by controls, used by audio and GUI (GUI currently does not use all expander data)
	bool midi_connected = false;
	uint32_t num_button_expanders_found = 0;
	uint32_t ext_buttons_pressed_event = 0;
	uint32_t ext_buttons_released_event = 0;
	uint32_t num_knob_expanders_found = 0;
	std::array<std::array<float, 8>, 4> exp_knobs{};

	// Populated by audio, which passes to GUI
	// TODO: move this out of MetaParams and do something like LightWatcher
	// so we can watch any arbitrary jack(s)
	std::array<float, PanelDef::NumAudioIn> ins{};
	uint8_t audio_load = 0;

	// Populated by audio, passed to controls
	uint32_t sample_rate = 48000;
	uint32_t block_size = 48000;
	uint32_t button_leds = 0;

	// Populated by audio, passed to controls and GUI
	uint32_t midi_poly_chans = 1;

	// Populated by GUI, used by GUI
	// TODO: move this to a PageManager object like gui_state
	RotaryMotion rotary_with_metabutton{};
	bool ignore_metabutton_release = false;

	MetaParams() {
		clear();
	}

	void clear() {
		for (auto &but : meta_buttons)
			but.reset();
		rotary_button.reset();
		rotary.motion = 0;
		rotary.abs_pos = 0;
		rotary_pushed.motion = 0;
		rotary_pushed.abs_pos = 0;
		audio_load = 0;
		ext_buttons_pressed_event = 0;
		ext_buttons_released_event = 0;
		num_button_expanders_found = 0;
		num_knob_expanders_found = 0;
	}

	// For rotary motion: adds events in `that` to events in `this`, leaving `that` untouched
	// For buttons: moves events from `that` to `this`, removing them from `this`
	// Copies non-event signals (CV, audio)
	// Used with write_sync(), which is called from audio thread to copy audio and control-generated data to GUI
	void update_with(MetaParams &that) {
		for (auto [but, thatbut] : zip(meta_buttons, that.meta_buttons))
			but.transfer_events(thatbut);

		rotary_button.transfer_events(that.rotary_button);
		rotary.add_motion(that.rotary);
		rotary_pushed.add_motion(that.rotary_pushed);
		audio_load = that.audio_load;

		midi_connected = that.midi_connected;

		midi_poly_chans = that.midi_poly_chans;

		for (auto [in, thatin] : zip(ins, that.ins))
			in = thatin;

		for (auto [exp_knob, that_exp_knob] : zip(exp_knobs, that.exp_knobs))
			exp_knob = that_exp_knob;
	}

	// For buttons: moves events from `that` to `this`, removing them from `this`
	// Moves rotary motion events from `that` to `this` (removing them from `that`, and adding them to existing events
	// in `this`
	// Copies non-event signals (CV, audio)
	// Used with read_sync(), for copying data generated by audio or controls to GUI
	void transfer(MetaParams &that) {
		for (auto [but, thatbut] : zip(meta_buttons, that.meta_buttons))
			but.transfer_events(thatbut);

		rotary_button.transfer_events(that.rotary_button);
		rotary.transfer_motion(that.rotary);
		rotary_pushed.transfer_motion(that.rotary_pushed);
		audio_load = that.audio_load;

		midi_connected = that.midi_connected;

		midi_poly_chans = that.midi_poly_chans;

		for (auto [in, thatin] : zip(ins, that.ins))
			in = thatin;

		for (auto [exp_knob, that_exp_knob] : zip(exp_knobs, that.exp_knobs))
			exp_knob = that_exp_knob;
	}
};

} // namespace MetaModule
